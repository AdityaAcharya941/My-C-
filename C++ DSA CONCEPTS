// #include<iostream>
//  using namespace std;
//  class node{
//  public:
//  int value;
//  node *next;
//  node(int x)
//  {
//  value = x;
//  next = nullptr;
//  }
//  };
//  class LinkedList{
//     private:
//     node *head;
//     public: 
//     LinkedList()
//     {
//     head = nullptr;
//     }
//  void addFirst(int num)
//  {
//     node *temp = new node(num); 
//    // dynamic node
//     temp->next = head;
//     head = temp;
//     }
//  void addLast(int num)
//  {
//     node *temp = new node(num);
//     if(head == nullptr)
//     head = temp;
//     else
//     {
//     node *ptr = head;
//     while(ptr->next != nullptr)
//     {
//     ptr = ptr->next;
//     }
//     ptr->next = temp;
//     }
//  }
//  void output()
//  {
//     node *ptr = head;
//     while(ptr != nullptr)
//     {
//     cout<<ptr->value<<" ";
//     ptr = ptr->next;
//     }
//     cout<<endl;
//  }
//  void addAfter(int num, int loc)
//  {
//     node*ptr = head;
//     while(ptr != nullptr && ptr->value != loc)
//     ptr = ptr->next;
//     if(ptr == nullptr)
//     {
//     cout<<"Location not found\n";
//     return;
//     }
//     node *temp = new node(num);
//     temp->next = ptr->next;
//     ptr->next = temp;
//  }
//  void addBefore(int num, int loc)
//  {
//     if(head == nullptr)
//     {
//     cout<<"Empty List\n";
//     return;
//     }
//     if(head->value == loc)
//     {
//     addFirst(num);
//     return;
//     }
//     node*ptr = head;
//     while(ptr->next != nullptr && ptr->next->
//     value != loc)
//     ptr = ptr->next;
//     if(ptr->next == nullptr)
//     {
//     cout<<"Location not found\n";
//     return;
//     }
//     node *temp = new node(num);
//     temp->next = ptr->next;
//     ptr->next = temp;
//  }
//  void delFirst()
//  {
//     if(head == nullptr)
//     {
//     cout<<"Empty List\n";
//     return;
//     }
//     node *ptr = head;
//     head=head->next;
//     cout<<ptr->value<<" deleted\n";
//     delete ptr;
//  }
//  void delLast()
//  {
//     if(head == nullptr)
//     {
//     cout<<"Empty List\n";
//     return;
//     }
//     node *ptr = head;
//     if(head->next == nullptr)
//     {
//     head = nullptr;
//     }
//     else{
//     node *ptr2 = nullptr;
//     while(ptr->next != nullptr)
//     {
//     ptr2 = ptr;
//     ptr = ptr->next;
//     }
//     ptr2->next = nullptr;
//     }
//     cout<<ptr->value<<" deleted\n";
//     delete ptr;
//  }
//  };
// int main()
// {
//  LinkedList list;
//  list.addFirst(10);
//  list.addFirst(20);
//  list.addFirst(30);
//  list.addFirst(40);
//  list.output();
//  list.addLast(70);
//  list.addLast(60);
//  list.output();
//  list.addAfter(100,60);
//  list.output();
//  list.addBefore(200,40);
//  list.output();
//  list.delFirst();
//  list.output();
//  list.delLast();
//  list.output();
// }

//tree
// #include<iostream>
// using namespace std;

// class Node {
//     public:
//     int data;
//     Node* left;
//     Node* right;

//     Node(int val) {
//         data = val;
//         right = NULL;
//         left = NULL;
//     }
// };


// void preorder(Node* root) {
//     if (root == NULL) {
//         return;
//     }
//     cout << root->data << " ";
//     preorder(root->left);
//     preorder(root->right);
// }

// void inorder(Node* root) {
//     if (root == NULL) {
//         return;
//     }
//     inorder(root->left);
//     cout << root->data << " ";
//     inorder(root->right);
// }

// void postorder(Node* root) {
//     if (root == NULL) {
//         return;
//     }
//     postorder(root->left);
//     postorder(root->right);
//     cout << root->data << " ";
// }

// int main() {
//     Node* root = new Node(5);
//     root->left = new Node(10);
//     root->right = new Node(30);
//     root->right->left = new Node(38);
//     root->left->left = new Node(38);

//     cout << "Preorder Traversal: ";
//     preorder(root);
//     cout << endl;

//     cout << "Inorder Traversal: ";
//     inorder(root);
//     cout << endl;

//     cout << "Postorder Traversal: ";
//     postorder(root);
//     cout << endl;

//     return 0;
// }

//Bst
// #include<iostream>
// #include<queue>
//  using namespace std;
//  class node{
//  public:
//     int val;
//     node *left,*right;
//     node(int x)
//     {
//     val=x;
//     left=right=nullptr;
//     }
//     };
//     class BST{
//     node*root;
//     pair<node*,node*> pp;
//     public:
//     BST()
//  {
//  root=nullptr;
//  }
//  bool search(int num)
//  {
//     node *ptr = root;
//     node *par = nullptr;
//     while(ptr != nullptr)
//     {
//     if(num == ptr->val)
//     {
//     pp=pair<node*, node*>(ptr,par);
//     return true;
//     }
//     par = ptr;
//     if(num < ptr->val)
//     ptr = ptr->left;
//     else
//     ptr = ptr->right;
//     }
//     pp=pair<node*, node*>(ptr,par);
//     return false;
//  }
//  void addBST(int num)
//  {
//     if(search(num))
//     {
//     cout<<"Duplicate element\n";
//     return;
//     }
//     node* par = pp.second;
//     if(par == nullptr)
//     {
//     root= new node(num);
//     }
//     else
//     {
//     if(num < par->val)
//     par->left = new node(num);
//     else
//     par->right=new node(num);
//  }
//  }
//  void inorder(node* root)
//  {
//     if(root==nullptr)
//     return;
//     inorder(root->left);
//     cout<<root->val<<" ";
//     inorder(root->right);
//  }
//  void traverse()
//  { 
//     inorder(root);
//     cout<<endl;
//  }
//  void levelOrder()
//     {
//         queue<node*> Q;
//         Q.push(root);
//         Q.push(nullptr);
//         while (!Q.empty())
//         {
//             node*temp = Q.front();
//             Q.pop();
//             cout<<temp->val<<" ";
//             if(temp->left != nullptr)
//             continue;
//             Q.push(temp->left);
//             if(temp->right != nullptr)
//             Q.push(temp->right);
//         }
//     }
//  };
//  int main()
//  {
//  BST tree;
//  tree.addBST(10);
//  tree.addBST(8);
//  tree.addBST(9);
//  tree.addBST(12);
//  tree.addBST(11);
//  tree.addBST(13);
//  tree.addBST(7);
//  tree.traverse();
//  tree.levelOrder();
//  cout<<endl;
//  cout<<endl;
//  return 0;
//  }

//graph// USING QUEUE
// #include<iostream>
// #include<vector>
// #include<queue>
// using namespace std;
// void BFS(vector<vector<int>>&g)
// {
//     int n = g.size();
//     vector<bool> status(n, false);
//     queue<int> Q;
//     Q.push(0);
//     status[0]=true;
//     while(!Q.empty()){
//         int x = Q.front();
//         Q.pop();
//         cout<<x<<" ";
//         for(int i = 0; i<n; i++)
//         {
//             if(g[x][i])
//             {
//                 if(status[i]==false)
//                 {
//                     Q.push(i);
//                     status[i]=true;
//                 }
//             }
//         }
//     }
// }
// int main()
// {
//     vector<vector<int>> graph ={
//                                 {0,1,1,0},
//                                 {1,0,1,1},
//                                 {1,1,0,1},
//                                 {0,1,1,0}
//     };
//     BFS(graph);
// }
//GRAPH USINF STACK 
// #include<iostream>
// #include<vector>
// #include<stack>
// using namespace std;
// void DFS(vector<vector<int>>&g)
// {
//     int n = g.size();
//     vector<bool> status(n, false);
//     stack<int> S;
//     S.push(0);
//     status[0]=true;
//     while(!S.empty()){
//         int x = S.top();
//         S.pop();
//         cout<<x<<" ";
//         for(int i = 0; i<n; i++)
//         {
//             if(g[x][i])
//             {
//                 if(status[i]==false)
//                 {
//                     S.push(i);
//                     status[i]=true;
//                 }
//             }
//         }
//     }
// }
// int main()
// {
//     vector<vector<int>> graph ={
//                                 {0,1,1,0},
//                                 {1,0,1,1},
//                                 {1,1,0,1},
//                                 {0,1,1,0}
//     };
//     DFS(graph);
// }

// #include <iostream>
// #include <queue>
// using namespace std;
// // Definition of a Tree Node
// struct TreeNode {
//     int val;
//     TreeNode* left;
//     TreeNode* right;
    
//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
// };

// // Function for Level-Order Traversal


// // Example Tree Construction
// int main() {
//     // Creating the tree
//     TreeNode* root = new TreeNode(7);
//     root->left = new TreeNode(8);
//     root->right = new TreeNode(9);
//     root->left->left = new TreeNode(10);
//     root->left->right = new TreeNode(11);
//     root->right->left = new TreeNode(12);
//     root->right->right = new TreeNode(13);

//     // Printing the tree levels
//     printTreeLevels(root);

//     return 0;
// }
